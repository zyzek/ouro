
-------------------------------------------------------------------------------
COMP3109 Assignment 2. Compiler Front End

Name

  Anton Jurisevic
  Jeremy Short
  Trung Tran


What tasks did you complete?

  Task 1 - Syntax and Semantics Analysis
  Task 2 - Intermediate Code Generation
  Task 3 - Interpreter
  Task 4 - Infix Operators
  Task 5 - While Loops

  Other:
  + Richer operators:
    - Operator precedence;
    - Extended arithmetic and logical operations;
    - Unary/Binary operator distinction.

  + Extended language semantics:
    - Expressions go where only ids could before;
    - Multiple-assignment:
        a, b, c  =  1, (1 + c), -b;
    - Functions as operators:
              func(x, y);  <->  x [func] y;
        func(a, b, c, d);  <->  a [func c,d] b;
    - Operator assignment: 
        x = x + 1;        <->   x += 1;
        x = func(x, y, z);   <->   x [func z]= y;
    - Single-assignments can be evaluated as expressions,
      for chained assignment;
    - Conditional/Ternary Operator;
    - "Ouroboros" recursion operator: calls its enclosing function;
    - Comments;
    - Print statement.

  + Source file preprocessor for library importation:
    - Handles circular dependencies;
    - Included math and number-theory toy libraries.

  + Several extra semantic checks and warnings.
    - Checks that multiple assignments are correct.
    - Check that functions actually return.
    - Some warnings if you have unreachable or redundant code.

  + Relatively extensive example code base.
    - For the most part, example code in the test/ directory demonstrates language features.
      To this end, many of the source files are annotated, and can only be parsed, converted
        with the -e flag given to imp.
      However, most of the files in test/fails are not extended, and simply demonstrate features
       of the checker.
      Similarly, anything in test/works/unextended can be run with the unextended language, and
       should run on other peoples' interpreters/compilers.


  Invocation:
    Run imp from the root directory, which holds Main.hs, in order that it can find the lib/
     folder.
    
    Input source is contained in .imp files. IR code is stored in .ir files. 
    For both of these, -lex tokenises a given file, and -interpret attempts to run it with the
      arguments you have given.
    -convert transforms input source into the intermediate representation, and -check operates 
      exclusively on the AST, so these are unavailable for .ir files.
    Finally, -parse works on both languages, but it produces the AST resulting from an .imp file,
      whereas it prints out the Haskell data structure representing a parsed .ir file.

    If you want to switch to the extended grammar, provide the -e flag first:

        imp [-e] -lex|-parse|-check|-convert|-interpret file [args ... ]
    
    The non-extended grammar includes while loops and infix operators with precedence, but
      none of the futher features.

Did you get stuck, or couldn't work something out?

  Not enough time for everything.
  Some things that were unfinished:
    - A type system, half-done.
    - Actually-informative syntax errors with line numbers.
    - Static expression reduction, substitution of constants for variables if possible in the AST.


-------------------------------------------------------------------------------
1. Install the Haskell Platform.
   Current version is 7.10.2
   https://www.haskell.org/platform/

   If this works you should now have the 'ghc', 'ghci' and 'cabal' commands.

   Cabal is the Haskell package manager and build tool.

   You can check the current install ghc version:

   $ ghc --version


2. Update the cabal package directory.
   This gets the list of available libraries from the online Hackage database.
   https://hackage.haskell.org/

   $ cabal update


3. Install some extra libraries.
   The template code uses these.
   The following command downloads them from Hackage.

   $ cabal install pretty-show
   $ cabal install Diff


4. Build the template code.

   $ cabal configure
   $ cabal build


5. Run some tests.

   The compiled executable is written to dist/build/imp/imp

   $ dist/build/imp/imp -lex test/works/factorial.imp


6. If you like, install your compiler.

   $ cabal install

   The executable will be installed in your system, 
   though the exact place depends on your OS.

   On OSX:   /Users/USER/Library/Haskell/bin
   On Linux: ~/.cabal/bin

   Add the correct directory to your $PATH.
