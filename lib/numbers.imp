fun  factorial(n)
vars count, total
{       
    total = 1;

    while (count < n) 
    {       
        count (+)= 1;
        total (*)= count;
    }
    
    return total;
}

fun fibonacci(n)
vars tmp, pred, prepred, sign
{
	if (n < 0) then 
	{ 
		n = -n;
		sign = (((n % 2) * 2) - 1);
	}
	else 
	{
		sign = 1;
	} 
	pred = 1;
	prepred = 0;

	while (n != 0)
	{
		tmp = pred;
		pred = (prepred + pred); 
		prepred = tmp;

		n (-)= 1;
	}

	return (prepred * sign);
}


fun perm(n, r)
{
	return (factorial(n) / factorial((n - r)));
}


fun  binom(n, r)
{   
    return (perm(n,r) / factorial(r));
}


fun catalan(n)
{
	return (binom((2 * n), n) / (n + 1));
}


fun sqrt(n)
vars val
{
	while ((val^2) <= n)
	{
		val (+)= 1;
	}

	return (val - 1);	
}


fun isPrime(n)
vars max, factor
{
	max = sqrt(n);
	factor = 2;

	while (factor <= max) 
	{
		if !(n % factor) then
		{
			return false;
		}

		factor (+)= 1;
	} 

	if (n <= 1) then {return false;} else {return true;}
}


fun prime(n)
vars pcount, cand
{
	if (n < 1) then
	{
		return 0;
	}

	cand = 1;

	while (pcount < n) 
	{
		cand (+)= 1;

		if isPrime(cand) then
		{
			pcount (+)= 1;
		}
	}

	return cand;
}

fun numPrimeDivisors(n) 
vars i, p, k
{
	i = 1;
	p = prime(i);

	while (n > 1) {
		if !(n % p) then
		{
			k (+)= 1;
			n (/)= p;
		}
		else
		{
			i (+)= 1;
			p = prime(i);
		}
	}

	return k;
}

fun phi(n) 
vars i, p, k, pPhi, result
{
	i = 1;
	p = prime(i);
	result = 1;

	while (n > 1) {
		if !(n % p) then
		{
			k (+)= 1;
			n (/)= p;
		}
		else
		{
			if (k > 0) then
			{
				result (*)= ((p^(k - 1)) * (p - 1));
				k = 0;
			}

			i (+)= 1;
			p = prime(i);
		}
	}

	if (k > 0) then
		{
			result (*)= ((p^(k - 1)) * (p - 1));
			k = 0;
		}

	return result;
}


fun gcd(a, b)
{
	if !(a % b) then 
	{
		return b;
	}
	return gcd(b, (a % b));
}

fun triangular(n) 
{
	return (((n + 1) * n) / 2);
}

fun ackermann(m, n)
{
	if !m then
	{
		return (n + 1);
	}
	else
	{
		if !n then 
		{
			return ackermann((m - 1), 1);
		}
		else
		{
			return ackermann( (m - 1), ackermann(m, (n - 1)) );
		}
	}
}

fun knuthUpArrow(a, b, p) 
vars r, pdec, bdec
{
	if (p == 1) then
	{
		return (a^b);
	}

	if (b == 1) then
	{
		return a;
	}

	r = knuthUpArrow(a, (b - 1), p);
	return knuthUpArrow(a, r, (p - 1));
}
