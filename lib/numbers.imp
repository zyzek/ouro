fun factorial(n)
vars total
{       
    total = 1;

    while (n > 1) 
    {       
        total (*)= n;
        n (-)= 1;
    }
    
    return total;
}


fun fibonacci(n)
vars tmp, pred, prepred, sign
{
    if (n < 0) then 
    { 
        n = -n;
        sign = (((n % 2) * 2) - 1);
    }
    else 
    {
        sign = 1;
    } 
    pred = 1;
    prepred = 0;

    while (n != 0)
    {
        tmp = pred;
        pred (+)= prepred;
        prepred = tmp;
        
        n (-)= 1;
    }

    return (prepred * sign);
}


fun perm(n, r)
{
    return (factorial(n) / factorial((n - r)));
}


fun  binom(n, r)
{   
    return (perm(n,r) / factorial(r));
}


fun catalan(n)
{
    return (binom((2 * n), n) / (n + 1));
}


fun sqrt(n)
vars val
{

    while ((val^2) <= n)
    {
        val (+)= 1;
    }

    return (val - 1);    
}


fun isPrime(n)
vars max, factor
{
    max = sqrt(n);
    factor = 2;

    while (factor <= max) 
    {
        if !(n % factor) then
        {
            return false;
        }

        factor (+)= 1;
    } 

    return (n > 1);
}


fun prime(n)
vars pcount, cand
{
    if (n < 1) then
    {
        return 0;
    }

    cand = 1;

    while (pcount < n) 
    {
        cand (+)= 1;

        if isPrime(cand) then
        {
            pcount (+)= 1;
        }
    }

    return cand;
}

fun numPrimeDivisors(n) 
vars i, p, k
{
    i = 1;
    p = prime(i);

    while (n > 1) {
        if !(n % p) then
        {
            k (+)= 1;
            n (/)= p;
        }
        else
        {
            i (+)= 1;
            p = prime(i);
        }
    }

    return k;
}

fun phi(n) 
vars i, p, k, pPhi, result
{
	i = 1;
	p = prime(i);
	result = 1;

	while (n > 1) {
		if !(n % p) then
		{
			k (+)= 1;
			n (/)= p;
		}
		else
		{
			if (k > 0) then
			{
				result (*)= ((p ^ (k - 1)) * (p - 1));
				k = 0;
			}

			i (+)= 1;
			p = prime(i);
		}
	}

	if (k > 0) then
		{
			result (*)= ((p ^ (k - 1)) * (p - 1));
			k = 0;
		}

	return result;
}


fun gcd(a, b)
{
    if !(a % b) then 
    {
        return b;
    }

    return @(b, (a % b));
}

fun triangular(n) 
{
    return (((n + 1) * n) / 2);
}

fun ackermann(m, n)
{

    if !m then
    {
        return (n + 1);
    }
    else 
    {
        if !n then 
        {
            return @((m - 1), 1);
        }
        else
        {
            return @((m - 1), @(m, (n - 1)));
        }
    }
}

fun knuthUpArrow(a, b, p) 
{
    if (p == 1) then
    {
        return (a ^ b);
    }

    if (b == 1) then
    {
        return a;
    }

    return @(a, @(a, (b - 1), p), (p - 1));
}
